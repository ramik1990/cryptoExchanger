import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// node_modules/crypto-convert/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/crypto-convert/dist/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isValidUrl = exports2.isEmpty = exports2.formatNumber = exports2.getAverage = exports2.symbolMap = void 0;
    function symbolMap(symbol, map, recurisve = false) {
      const mapKeys = Object.keys(map);
      for (var c = 0; c < mapKeys.length; c++) {
        if (symbol.length >= mapKeys[c].length + 3 && (symbol.endsWith(mapKeys[c]) || symbol.startsWith(mapKeys[c]))) {
          const cleaned = symbol.replace(mapKeys[c], map[mapKeys[c]]);
          if (recurisve) {
            return symbolMap(cleaned, map, false);
          }
          return cleaned;
        }
      }
      return symbol;
    }
    exports2.symbolMap = symbolMap;
    function getAverage(pairs) {
      if (!pairs.length) {
        return {};
      }
      ;
      const allPairs = pairs.flatMap((pair) => Object.keys(pair)).filter((pair, i2, arr) => arr.indexOf(pair) == i2);
      return allPairs.reduce((o, pair) => {
        let values = pairs.map((e) => e[pair]).filter((v) => v), averageValue = formatNumber(values.reduce((sum, v) => sum + v, 0) / values.length, 8);
        o[pair] = averageValue;
        return o;
      }, {});
    }
    exports2.getAverage = getAverage;
    function formatNumber(n, decimals) {
      if (typeof n != "number") {
        n = Number(n);
        if (isNaN(n)) {
          return NaN;
        }
      }
      let s = typeof decimals == "number" ? n.toFixed(decimals) : n + "";
      let clean = s.match(/\./) && !s.match(/[eE]/) ? s.replace(/0+$/g, "").replace(/\.+$/g, "") : s;
      return parseFloat(clean);
    }
    exports2.formatNumber = formatNumber;
    function isEmpty(obj) {
      if (!obj) {
        return true;
      }
      for (var _ in obj) {
        return false;
      }
      return true;
    }
    exports2.isEmpty = isEmpty;
    function isValidUrl(string) {
      try {
        return /^https?\:\/\//.test(new URL(string).protocol);
      } catch (err) {
        return false;
      }
    }
    exports2.isValidUrl = isValidUrl;
    exports2.isBrowser = typeof window !== "undefined" && window.document;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalObject);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  }
});

// node_modules/form-data/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports2, module2) {
    module2.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/rests/lib/index.js
var require_lib = __commonJS({
  "node_modules/rests/lib/index.js"(exports2, module2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    function Rests(endpoints, options) {
      const fetch = typeof window !== "undefined" ? window === null || window === void 0 ? void 0 : window.fetch : require_browser(), FormData = typeof window !== "undefined" ? window === null || window === void 0 ? void 0 : window.FormData : require_browser2();
      if (!fetch) {
        throw new Error("Fetch API is not installed. If you are using Node please run `npm install node-fetch`");
      }
      if (!FormData) {
        throw new Error("FormData is not installed. If you are using Node please run `npm install form-data`");
      }
      const copyOptions = (o) => Object.assign(Object.assign({}, o), { headers: Object.assign({}, o.headers), params: Object.assign({}, o.params), values: Object.assign({}, o.values) });
      const parseSet = (values) => {
        var _a, _b;
        if (((_b = (_a = values === null || values === void 0 ? void 0 : values.__proto__) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) != "Object") {
          throw new Error("Invalid $options object.");
        }
        let saveOptions = copyOptions(values.$options || {});
        delete values["$options"];
        return Object.assign(Object.assign({}, saveOptions), { values: Object.assign(Object.assign({}, saveOptions.values), values) });
      };
      const mergeOptions = (prevOptions, currentOptions, mutate = false) => {
        let firstOptions = mutate ? prevOptions || {} : copyOptions(prevOptions || {});
        let secondOptions = copyOptions(currentOptions || {});
        secondOptions.headers = Object.assign(Object.assign({}, firstOptions.headers), secondOptions.headers);
        secondOptions.params = Object.assign(Object.assign({}, firstOptions.params), secondOptions.params);
        secondOptions.values = Object.assign(Object.assign({}, firstOptions.values), secondOptions.values);
        Object.assign(firstOptions, secondOptions);
        return firstOptions;
      };
      endpoints = Object.assign({}, endpoints);
      let global_options = {
        base: "",
        headers: {
          "User-Agent": "Rests JS (v1.1.0)"
        },
        params: {},
        values: {},
        on_error: void 0,
        on_success: void 0,
        on_request: void 0,
        fetch_agent: null
      };
      mergeOptions(global_options, (endpoints === null || endpoints === void 0 ? void 0 : endpoints.$options) || {}, true);
      mergeOptions(global_options, options, true);
      const def_param_enctypes = {
        "json": "application/json",
        "form": "multipart/form-data",
        "urlencoded": "application/x-www-form-urlencoded",
        "text": "text/plain"
      }, allowed_param_enctypes = Object.values(def_param_enctypes), allowed_param_locations = ["headers", "body", "query", "path"], def_param_locations = {
        "POST": "body",
        "GET": "query"
      };
      const serializers = {
        "multipart/form-data": function() {
          var formData = new FormData();
          formData.toString = function() {
            return this;
          };
          return formData;
        },
        "application/x-www-form-urlencoded": function() {
          return new URLSearchParams();
        },
        "application/json": function() {
          return {
            append: function(key, value) {
              this.data = this.data || {};
              this.data[key] = value;
            },
            toString: function() {
              return JSON.stringify(this.data);
            },
            isEmpty: function() {
              return !this.data || Object.keys(this.data).length == 0;
            }
          };
        },
        "text/plain": function() {
          return {
            append: function(_, value) {
              this.data = this.data || [];
              return this.data.push(value);
            },
            toString: function() {
              return this.data.join("");
            },
            isEmpty: function() {
              return !this.data || this.data.length == 0;
            }
          };
        }
      };
      const isNull = (value) => {
        return value === null || value === void 0;
      };
      const isEmptyIterable = (iterable) => {
        for (var _ of iterable) {
          return false;
        }
        return true;
      };
      const escapeRegExp = (string) => {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      };
      const capitalize = (string) => {
        return string.substr(0, 1).toUpperCase() + string.substr(1, string.length);
      };
      const formToJson = (f) => {
        return Object.fromEntries(Array.from(f.keys(), (k) => k.endsWith("[]") ? [k.slice(0, -2), f.getAll(k)] : [k, f.get(k)]));
      };
      const get = (t, path) => path.split(".").reduce((r, k) => r === null || r === void 0 ? void 0 : r[k], t);
      const getOne = (...args) => {
        for (var i2 = 0; i2 < args.length; i2++) {
          if (args[i2] !== null && args[i2] !== void 0) {
            return args[i2];
          }
        }
        return null;
      };
      const sendRequest = (url, options2, currentOptions, requestInfo) => __awaiter2(this, void 0, void 0, function* () {
        return fetch(url, options2).then(function(res) {
          var _a;
          return __awaiter2(this, void 0, void 0, function* () {
            try {
              var contentType = res.headers.get("Content-Type") || "";
              let corsType;
              try {
                corsType = res.type;
              } catch (err) {
              }
              let formattedResponse = {
                statusCode: res.status,
                statusText: res.statusText,
                headers: res.headers,
                type: corsType,
                ok: res.ok
              };
              let responseTypes = {
                "application/json": "json",
                "text/plain": "text",
                "(multipart/form-data|application/x-www-form-urlencoded)": "formData",
                "blob": "blob",
                "text": "text"
              };
              let currentResponseType = Object.keys(responseTypes).find((responseType) => new RegExp(responseType).test(contentType)) || "text";
              formattedResponse[responseTypes[currentResponseType]] = yield res[responseTypes[currentResponseType]]();
              formattedResponse["message"] = ((_a = formattedResponse === null || formattedResponse === void 0 ? void 0 : formattedResponse.json) === null || _a === void 0 ? void 0 : _a.message) || (res.ok ? "Success." : "Something went wrong.");
              if (!res.ok) {
                throw formattedResponse;
              }
              if (currentOptions.on_success) {
                let successCallbackRes = currentOptions.on_success(formattedResponse, requestInfo);
                if (successCallbackRes !== void 0) {
                  return successCallbackRes;
                }
              }
              return formattedResponse;
            } catch (err) {
              if (currentOptions.on_error) {
                let errorCallbackRes = currentOptions.on_error(err, requestInfo);
                if (errorCallbackRes !== void 0) {
                  return errorCallbackRes;
                }
              }
              return Promise.reject(err);
            }
          });
        });
      });
      function wrap(endpoint, categoryOptions, categoryKey) {
        endpoint.method = (endpoint.method || "get").toUpperCase(), endpoint.params = endpoint.params || {};
        const sender = function(params) {
          var _a, _b, _c, _d, _e, _f;
          return __awaiter2(this, void 0, void 0, function* () {
            if (this instanceof sender) {
              throw new Error("This is an endpoint, you can't initialize this.");
            }
            var currentOptions = mergeOptions(global_options, categoryOptions);
            currentOptions.on_request = endpoint.on_request || currentOptions.on_request;
            currentOptions.on_success = endpoint.on_success || currentOptions.on_success;
            currentOptions.on_error = endpoint.on_error || currentOptions.on_error;
            var url = `${currentOptions.base}${endpoint.path}`;
            if ((params === null || params === void 0 ? void 0 : params["$sandbox"]) || ((_a = currentOptions === null || currentOptions === void 0 ? void 0 : currentOptions.values) === null || _a === void 0 ? void 0 : _a["$sandbox"])) {
              url = `${currentOptions.sandboxBase || currentOptions.base}${endpoint.path}`;
            }
            var options2 = {
              method: endpoint.method,
              headers: Object.assign({}, currentOptions.headers),
              agent: currentOptions.fetch_agent
            };
            var enctype = allowed_param_enctypes.includes(endpoint.enctype) ? endpoint.enctype : def_param_enctypes[endpoint.enctype || "json"];
            var request_params = Object.assign({}, currentOptions.params, endpoint.params);
            var bodySerializer = serializers[enctype](), querySerializer = new URLSearchParams();
            if (((_b = params === null || params === void 0 ? void 0 : params.constructor) === null || _b === void 0 ? void 0 : _b.name) == "FormData") {
              params = formToJson(params);
            } else {
              params = params || {};
            }
            for (var param_name in request_params) {
              var param = request_params[param_name];
              var current_param_value = params[param_name], options_param_value = (_c = currentOptions === null || currentOptions === void 0 ? void 0 : currentOptions.values) === null || _c === void 0 ? void 0 : _c[param_name], default_param_value = param.default, example_param_value = (params === null || params === void 0 ? void 0 : params["$sandbox"]) || ((_d = currentOptions === null || currentOptions === void 0 ? void 0 : currentOptions.values) === null || _d === void 0 ? void 0 : _d["$sandbox"]) ? param.example : void 0;
              var param_value = getOne(current_param_value, options_param_value, example_param_value, default_param_value);
              var param_dest = param.name || param_name;
              var param_error = param.help || `The '${param_name}' field is invalid.`;
              if (param.required && isNull(param_value)) {
                var error = new Error(param_error);
                error.field = param_name;
                throw error;
              }
              if (isNull(param_value))
                continue;
              if (typeof param.format === "function") {
                try {
                  param_value = param.format(param_value);
                } catch (e) {
                  var error = new Error(e.message || param_error);
                  error.field = param_name;
                  throw error;
                }
              }
              if (param.type && param.type !== "any") {
                var error = new Error(param_error);
                error.field = param_name;
                if (["string", "boolean", "number"].includes(param.type) && typeof param_value != param.type || param.type == "array" && !Array.isArray(param_value) || param.type == "object" && (!param_value || param_value.__proto__.constructor.name !== "Object")) {
                  throw error;
                }
              }
              if (param.validate) {
                if (((_f = (_e = param.validate) === null || _e === void 0 ? void 0 : _e.constructor) === null || _f === void 0 ? void 0 : _f.name) == "RegExp") {
                  param.validate["toJSON"] = function() {
                    return param.validate.toString().replace(/^\//g, "").replace(/\/$/g, "");
                  };
                }
                if (!new RegExp(param.validate).test(param_value)) {
                  var error = new Error(param_error);
                  error.field = param_name;
                  throw error;
                }
              }
              if (param.type == "number") {
                if (param.hasOwnProperty("max") && !isNaN(param.max) && Number(param_value) > Number(param.max)) {
                  var error = new Error(`The maximum allowed value allowed for the ${param_dest} parameter is ${param.max}`);
                  error.field = param_name;
                  throw error;
                }
                if (param.hasOwnProperty("min") && !isNaN(param.min) && Number(param_value) < Number(param.min)) {
                  var error = new Error(`The minimum allowed value allowed for the ${param_dest} parameter is ${param.min}`);
                  error.field = param_name;
                  throw error;
                }
              }
              if (param.in && Array.isArray(param.in) && !param.in.includes(param_value)) {
                var error = new Error(`The ${param_dest} parameter should be one of these values: ${param.in}`);
                error.field = param_name;
                throw error;
              }
              var param_location = typeof param.location === "string" ? param.location.toLowerCase() : def_param_locations[options2.method];
              if (!param_location || !allowed_param_locations.includes(param_location)) {
                throw new Error(`Invalid location for '${param_name}' field.`);
              }
              if (param_location == "headers") {
                options2["headers"] = options2["headers"] || {};
                options2["headers"][param_dest] = param_value;
                continue;
              }
              if (param_location == "body") {
                bodySerializer.append(param_dest, param_value);
                continue;
              }
              if (param_location == "query") {
                querySerializer.append(param_dest, param_value);
                continue;
              }
              if (param_location == "path") {
                url = url.replace(new RegExp(`{${escapeRegExp(param_dest).trim()}}`), param_value);
              }
            }
            var hasQuery = querySerializer.toString();
            if (hasQuery) {
              url = `${url}?${hasQuery}`;
            }
            var isEmptyBody = bodySerializer.keys && isEmptyIterable(bodySerializer.keys()) || bodySerializer.getLengthSync && bodySerializer.getLengthSync() == 0 || bodySerializer.isEmpty && bodySerializer.isEmpty();
            if (!isEmptyBody) {
              options2["body"] = bodySerializer.toString();
            }
            if (options2["body"] && enctype !== "multipart/form-data") {
              options2["headers"] = options2["headers"] || {};
              options2["headers"]["Content-Type"] = enctype;
            }
            let requestInfo = {
              url,
              options: options2,
              params,
              key: categoryKey,
              instance: global_options["__$root_instance__"],
              self: wrap(endpoint, categoryOptions, categoryKey)
            };
            if (currentOptions.on_request) {
              var requestCallbackRes = yield Promise.resolve(currentOptions.on_request(requestInfo));
              if (requestCallbackRes) {
                if ((requestCallbackRes === null || requestCallbackRes === void 0 ? void 0 : requestCallbackRes.url) || (requestCallbackRes === null || requestCallbackRes === void 0 ? void 0 : requestCallbackRes.options)) {
                  url = requestCallbackRes.url || url;
                  options2 = requestCallbackRes.options || options2;
                } else {
                  return requestCallbackRes;
                }
              }
              if (requestCallbackRes === false) {
                return false;
              }
            }
            return sendRequest(url, options2, currentOptions, requestInfo);
          });
        };
        return sender;
      }
      function newCategory(name, categoryOptions, categoryName, isRoot) {
        name = name || "Rests";
        var New = {
          [name]: function(values) {
            if (!(this instanceof New[name])) {
              throw new Error("This is a category, you can initalize this category to update values using 'new' command.");
            }
            if (isRoot) {
              throw new Error("This is already initialized, you can use 'set' instead.");
            }
            let currentOptions = mergeOptions(global_options, categoryOptions);
            let updateOptions = parseSet(values);
            let newOptions = mergeOptions(currentOptions, updateOptions);
            return Rests(categoryName ? get(endpoints, categoryName) : endpoints, newOptions);
          }
        };
        if (isRoot) {
          New[name]["set"] = function(values) {
            if (this instanceof New[name]["set"]) {
              throw new Error("The set object can't be initialized.");
            }
            let updateOptions = parseSet(values);
            mergeOptions(global_options, updateOptions, true);
            return New[name];
          };
        }
        return New[name];
      }
      function traverse(root, schema, categoryOptions, categoryKey) {
        for (var category in schema) {
          var tree = schema[category];
          if (!tree || typeof tree !== "object") {
            continue;
          }
          if (typeof root[category] !== "undefined") {
            console.warn(`Skipping ${category} as it confilicts with another key in the object`);
            continue;
          }
          let categoryName = `${categoryKey ? categoryKey + "." : ""}${category}`;
          if (tree.hasOwnProperty("path")) {
            var endpoint = tree;
            root[category] = wrap(endpoint, categoryOptions, categoryName);
          } else {
            if (category.substr(0, 1) === "$") {
              continue;
            }
            let nextOptions = categoryOptions;
            if (tree === null || tree === void 0 ? void 0 : tree["$options"]) {
              nextOptions = mergeOptions(categoryOptions, tree === null || tree === void 0 ? void 0 : tree["$options"]);
            }
            root[category] = traverse(newCategory(category, nextOptions, categoryName), tree, nextOptions, categoryName);
          }
        }
        return root;
      }
      const rootCategory = Object.defineProperty(newCategory("Rests", global_options, void 0, true), "__schema__", {
        value: {
          schema: endpoints,
          options: global_options
        },
        writable: false,
        enumerable: false
      });
      global_options["__$root_instance__"] = rootCategory;
      return traverse(rootCategory, endpoints, {});
    }
    Rests.default = Rests;
    exports2.default = Rests;
    module2.exports = Rests;
  }
});

// node_modules/crypto-convert/dist/api.js
var require_api = __commonJS({
  "node_modules/crypto-convert/dist/api.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var rests_1 = __importDefault2(require_lib());
    var helpers_12 = require_helpers();
    var krakenPairsList;
    var closedMarketsBinance;
    var API = (0, rests_1.default)({
      binance: {
        $options: {
          base: "https://api.binance.com/api/v3"
        },
        bookTicker: {
          path: "/ticker/bookTicker",
          on_success: (response) => response.json
        },
        ticker: {
          path: "/ticker/price",
          on_request(request) {
            return __awaiter2(this, void 0, void 0, function* () {
              if (!closedMarketsBinance) {
                const bookTicker = yield request.instance.binance.bookTicker();
                closedMarketsBinance = bookTicker.map((pair) => {
                  if (parseFloat(pair.askPrice) <= 0) {
                    return pair.symbol;
                  }
                  return false;
                }).filter((p) => p);
              }
            });
          },
          on_success(response, request) {
            const usdPegs = {
              "USDT": "USD",
              "USDC": "USD",
              "BUSD": "USD"
            }, data = response.json;
            if (!data || !Array.isArray(data)) {
              throw new Error(`Invalid response from Binance: ${JSON.stringify(data)}`);
            }
            return data.reduce((obj, pair) => {
              if (closedMarketsBinance && closedMarketsBinance.indexOf(pair.symbol) !== -1) {
                return obj;
              }
              const bSymbol = (0, helpers_12.symbolMap)(pair.symbol, usdPegs), bPrice = parseFloat(pair.price);
              obj[bSymbol] = bPrice;
              return obj;
            }, {});
          }
        }
      },
      bitfinex: {
        $options: {
          base: "https://api-pub.bitfinex.com/v2"
        },
        ticker: {
          path: "/tickers",
          params: {
            symbols: {
              help: "The symbols you want information about as a comma separated list, or ALL for every symbol. (Examples of possible symbols: tBTCUSD, tETHUSD, fUSD, fBTC)",
              default: "ALL",
              type: "string"
            }
          },
          on_success: function(response) {
            const coinAliases = {
              "BAB": "BCH",
              "DSH": "DASH"
            }, data = response.json;
            if (!data || !Array.isArray(data)) {
              throw new Error(`Invalid response from Bitfinex: ${JSON.stringify(data)}`);
            }
            return data.reduce((obj, pair) => {
              if (!pair[0].startsWith("t")) {
                return obj;
              }
              const bSymbol = (0, helpers_12.symbolMap)(pair[0].replace(/^t/, ""), coinAliases, true).replace(":", ""), bPrice = parseFloat(pair[7]);
              obj[bSymbol] = bPrice;
              return obj;
            }, {});
          }
        }
      },
      coinbase: {
        $options: {
          base: "https://api.coinbase.com/v2"
        },
        ticker: {
          path: "/exchange-rates",
          params: {
            currency: {
              help: "The exchange currency (default USD)"
            }
          },
          on_success: (response) => {
            var _a;
            const data = (_a = response === null || response === void 0 ? void 0 : response.json) === null || _a === void 0 ? void 0 : _a.data;
            if (!data) {
              throw new Error(`Invalid response from Coinbase: ${data}`);
            }
            return Object.keys(data.rates).reduce((o, v, i2) => {
              const bSymbol = v + data.currency, bPrice = (0, helpers_12.formatNumber)(1 / parseFloat(data.rates[v]), 8);
              o[bSymbol] = bPrice;
              return o;
            }, {});
          }
        }
      },
      kraken: {
        $options: {
          base: "https://api.kraken.com/0/public"
        },
        pairs: {
          path: "/AssetPairs",
          on_success: (res) => {
            return Object.keys(res.json.result);
          }
        },
        ticker: {
          path: "/Ticker",
          on_request: (request) => __awaiter2(void 0, void 0, void 0, function* () {
            if (!krakenPairsList) {
              const assetPairs = yield request.instance.kraken.pairs();
              krakenPairsList = assetPairs;
            }
            return {
              url: request.url + "?pair=" + krakenPairsList
            };
          }),
          on_success: (response) => {
            var _a;
            const fixedSymbols = {
              "XETC": "ETC",
              "XETH": "ETH",
              "XLTC": "LTC",
              "XMLN": "MLN",
              "XREP": "REP",
              "XXBT": "BTC",
              "XXDG": "XDG",
              "XXLM": "XLM",
              "XXMR": "XMR",
              "XXRP": "XRP",
              "XZEC": "ZEC",
              "XBT": "BTC",
              "ZAUD": "AUD",
              "ZEUR": "EUR",
              "ZGBP": "GBP",
              "ZUSD": "USD",
              "ZCAD": "CAD",
              "ZJPY": "JPY"
            }, data = (_a = response.json) === null || _a === void 0 ? void 0 : _a.result;
            if (!data) {
              throw new Error(`Invalid response from Kraken: ${JSON.stringify(data)}`);
            }
            return Object.keys(data).reduce((obj, symbol) => {
              const bSymbol = (0, helpers_12.symbolMap)(symbol, fixedSymbols, true), bPrice = parseFloat(data[symbol].c[0]);
              obj[bSymbol] = bPrice;
              return obj;
            }, {});
          }
        }
      },
      coinmarketcap: {
        $options: {
          base: "https://api.coinmarketcap.com/data-api/v3"
        },
        top: {
          path: "/map/all",
          params: {
            limit: {
              default: "150"
            },
            listing_status: {
              default: "active"
            }
          },
          on_success: function(response) {
            const data = response.json;
            if (!data || !data.data || !Array.isArray(data.data.cryptoCurrencyMap)) {
              throw new Error(`Invalid response from CoinMarketCap: ${JSON.stringify(data)}`);
            }
            return data.data.cryptoCurrencyMap.reduce((o, v) => {
              o[v.symbol] = {
                id: v.id,
                title: v.name,
                symbol: v.symbol,
                logo: `https://s2.coinmarketcap.com/static/img/coins/128x128/${v.id}.png`,
                rank: v.rank
              };
              return o;
            }, {});
          }
        }
      },
      fiat: {
        all: {
          path: "https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml",
          on_success: function(response) {
            var xml = response.text;
            var currencies = [...xml.matchAll(/currency=["']([A-Za-z]+)["']/gi)];
            var rates = [...xml.matchAll(/rate=["']([.0-9]+)["']/gi)];
            var full = currencies.reduce((obj, v, index) => Object.assign(Object.assign({}, obj), { [v[1]]: rates[index][1] }), {});
            full["EUR"] = 1;
            return full;
          }
        }
      },
      coinconvert: {
        $options: {
          base: "https://api.coinconvert.net"
        },
        ticker: {
          path: "/v2/ticker",
          params: {
            v: {
              default: "2.1.6"
            },
            filterExchanges: {
              type: "array"
            },
            noAverage: {
              type: "boolean"
            }
          },
          on_success: (response) => response.json
        },
        list: {
          path: "/v2/list?v=2.1.6",
          on_success: (response) => response.json
        }
      }
    });
    exports2.default = API;
  }
});

// node_modules/crypto-convert/dist/worker.js
var require_worker = __commonJS({
  "node_modules/crypto-convert/dist/worker.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initialCoinList = void 0;
    var api_1 = __importDefault2(require_api());
    var helpers_12 = require_helpers();
    exports2.initialCoinList = {
      "crypto": [
        "BTC",
        "ETH",
        "USDT",
        "USDC",
        "BNB",
        "XRP",
        "BUSD",
        "ADA",
        "SOL",
        "DOGE",
        "DOT",
        "DAI",
        "MATIC",
        "SHIB",
        "TRX",
        "AVAX",
        "UNI",
        "WBTC",
        "LEO",
        "LTC",
        "ETC",
        "LINK",
        "ATOM",
        "FTT",
        "XLM",
        "NEAR",
        "CRO",
        "XMR",
        "ALGO",
        "BCH",
        "LUNC",
        "FLOW",
        "QNT",
        "VET",
        "TON",
        "FIL",
        "APE",
        "ICP",
        "CHZ",
        "HBAR",
        "MANA",
        "XTZ",
        "SAND",
        "EOS",
        "EGLD",
        "THETA",
        "AAVE",
        "AXS",
        "OKB",
        "USDP",
        "BSV",
        "KCS",
        "TUSD",
        "ZEC",
        "MIOTA",
        "XEC",
        "USDD",
        "MKR",
        "BTT",
        "HT",
        "GRT",
        "USDN",
        "HNT",
        "CAKE",
        "NEO",
        "KLAY",
        "FTM",
        "SNX",
        "PAXG",
        "RUNE",
        "NEXO",
        "LDO",
        "CRV",
        "GT",
        "DASH",
        "ENJ",
        "BAT",
        "COMP",
        "STX",
        "KAVA",
        "RVN",
        "ZIL",
        "WAVES",
        "FEI",
        "MINA",
        "RSR",
        "XDC",
        "LRC",
        "GMT",
        "DCR",
        "TWT",
        "CELO",
        "XEM",
        "BTG",
        "KSM",
        "HOT",
        "1INCH",
        "CEL",
        "CVX",
        "BNX",
        "AR",
        "GNO",
        "LUNA",
        "ROSE",
        "ENS",
        "USTC",
        "GUSD",
        "QTUM",
        "YFI",
        "ANKR",
        "TFUEL",
        "GALA",
        "GLM",
        "IOTX",
        "KDA",
        "BTRST",
        "ONE",
        "OMG",
        "BAL",
        "ZRX",
        "LPT",
        "POLY",
        "JST",
        "FLUX",
        "ICX",
        "BORA",
        "IOST",
        "HIVE",
        "AMP",
        "OP",
        "KNC",
        "XYM",
        "SRM",
        "ONT",
        "WAXP",
        "STORJ",
        "MXC",
        "CSPR",
        "IMX",
        "SC",
        "ZEN",
        "AUDIO",
        "GLMR",
        "SXP",
        "XCH",
        "ABBC",
        "CHSB",
        "VGX",
        "UMA",
        "WOO"
      ],
      "fiat": [
        "USD",
        "JPY",
        "BGN",
        "CZK",
        "DKK",
        "GBP",
        "HUF",
        "PLN",
        "RON",
        "SEK",
        "CHF",
        "ISK",
        "NOK",
        "HRK",
        "RUB",
        "TRY",
        "AUD",
        "BRL",
        "CAD",
        "CNY",
        "HKD",
        "IDR",
        "ILS",
        "INR",
        "KRW",
        "MXN",
        "MYR",
        "NZD",
        "PHP",
        "SGD",
        "THB",
        "ZAR",
        "EUR"
      ]
    };
    var PricesWorker = class {
      constructor(o) {
        this.exchanges = ["binance", "bitfinex", "coinbase", "kraken"];
        this.list = exports2.initialCoinList;
        this.cryptoInfo = [{ "id": 1, "title": "Bitcoin", "symbol": "BTC", "rank": 1 }, { "id": 1027, "title": "Ethereum", "symbol": "ETH", "rank": 2 }, { "id": 825, "title": "Tether", "symbol": "USDT", "rank": 3 }, { "id": 3408, "title": "USD Coin", "symbol": "USDC", "rank": 4 }, { "id": 1839, "title": "BNB", "symbol": "BNB", "rank": 5 }, { "id": 52, "title": "XRP", "symbol": "XRP", "rank": 6 }, { "id": 4687, "title": "Binance USD", "symbol": "BUSD", "rank": 7 }, { "id": 2010, "title": "Cardano", "symbol": "ADA", "rank": 8 }, { "id": 5426, "title": "Solana", "symbol": "SOL", "rank": 9 }, { "id": 74, "title": "Dogecoin", "symbol": "DOGE", "rank": 10 }, { "id": 6636, "title": "Polkadot", "symbol": "DOT", "rank": 11 }, { "id": 4943, "title": "Dai", "symbol": "DAI", "rank": 12 }, { "id": 3890, "title": "Polygon", "symbol": "MATIC", "rank": 13 }, { "id": 5994, "title": "Shiba Inu", "symbol": "SHIB", "rank": 14 }, { "id": 1958, "title": "TRON", "symbol": "TRX", "rank": 15 }, { "id": 5805, "title": "Avalanche", "symbol": "AVAX", "rank": 16 }, { "id": 7083, "title": "Uniswap", "symbol": "UNI", "rank": 17 }, { "id": 3717, "title": "Wrapped Bitcoin", "symbol": "WBTC", "rank": 18 }, { "id": 3957, "title": "UNUS SED LEO", "symbol": "LEO", "rank": 19 }, { "id": 2, "title": "Litecoin", "symbol": "LTC", "rank": 20 }, { "id": 1321, "title": "Ethereum Classic", "symbol": "ETC", "rank": 21 }, { "id": 1975, "title": "Chainlink", "symbol": "LINK", "rank": 22 }, { "id": 3794, "title": "Cosmos", "symbol": "ATOM", "rank": 23 }, { "id": 4195, "title": "FTX Token", "symbol": "FTT", "rank": 24 }, { "id": 512, "title": "Stellar", "symbol": "XLM", "rank": 25 }, { "id": 6535, "title": "NEAR Protocol", "symbol": "NEAR", "rank": 26 }, { "id": 3635, "title": "Cronos", "symbol": "CRO", "rank": 27 }, { "id": 328, "title": "Monero", "symbol": "XMR", "rank": 28 }, { "id": 4030, "title": "Algorand", "symbol": "ALGO", "rank": 29 }, { "id": 1831, "title": "Bitcoin Cash", "symbol": "BCH", "rank": 30 }, { "id": 4172, "title": "Terra Classic", "symbol": "LUNC", "rank": 31 }, { "id": 4558, "title": "Flow", "symbol": "FLOW", "rank": 32 }, { "id": 3155, "title": "Quant", "symbol": "QNT", "rank": 33 }, { "id": 3077, "title": "VeChain", "symbol": "VET", "rank": 34 }, { "id": 11419, "title": "Toncoin", "symbol": "TON", "rank": 35 }, { "id": 2280, "title": "Filecoin", "symbol": "FIL", "rank": 36 }, { "id": 18876, "title": "ApeCoin", "symbol": "APE", "rank": 37 }, { "id": 8916, "title": "Internet Computer", "symbol": "ICP", "rank": 38 }, { "id": 4066, "title": "Chiliz", "symbol": "CHZ", "rank": 39 }, { "id": 4642, "title": "Hedera", "symbol": "HBAR", "rank": 40 }, { "id": 1966, "title": "Decentraland", "symbol": "MANA", "rank": 41 }, { "id": 2011, "title": "Tezos", "symbol": "XTZ", "rank": 42 }, { "id": 6210, "title": "The Sandbox", "symbol": "SAND", "rank": 43 }, { "id": 1765, "title": "EOS", "symbol": "EOS", "rank": 44 }, { "id": 6892, "title": "Elrond", "symbol": "EGLD", "rank": 45 }, { "id": 2416, "title": "Theta Network", "symbol": "THETA", "rank": 46 }, { "id": 7278, "title": "Aave", "symbol": "AAVE", "rank": 47 }, { "id": 6783, "title": "Axie Infinity", "symbol": "AXS", "rank": 48 }, { "id": 3897, "title": "OKB", "symbol": "OKB", "rank": 49 }, { "id": 3330, "title": "Pax Dollar", "symbol": "USDP", "rank": 50 }, { "id": 3602, "title": "Bitcoin SV", "symbol": "BSV", "rank": 51 }, { "id": 2087, "title": "KuCoin Token", "symbol": "KCS", "rank": 52 }, { "id": 2563, "title": "TrueUSD", "symbol": "TUSD", "rank": 53 }, { "id": 1437, "title": "Zcash", "symbol": "ZEC", "rank": 54 }, { "id": 1720, "title": "IOTA", "symbol": "MIOTA", "rank": 55 }, { "id": 10791, "title": "eCash", "symbol": "XEC", "rank": 56 }, { "id": 19891, "title": "USDD", "symbol": "USDD", "rank": 57 }, { "id": 1518, "title": "Maker", "symbol": "MKR", "rank": 58 }, { "id": 16086, "title": "BitTorrent-New", "symbol": "BTT", "rank": 59 }, { "id": 2502, "title": "Huobi Token", "symbol": "HT", "rank": 60 }, { "id": 6719, "title": "The Graph", "symbol": "GRT", "rank": 61 }, { "id": 5068, "title": "Neutrino USD", "symbol": "USDN", "rank": 62 }, { "id": 5665, "title": "Helium", "symbol": "HNT", "rank": 63 }, { "id": 7186, "title": "PancakeSwap", "symbol": "CAKE", "rank": 64 }, { "id": 1376, "title": "Neo", "symbol": "NEO", "rank": 65 }, { "id": 4256, "title": "Klaytn", "symbol": "KLAY", "rank": 66 }, { "id": 3513, "title": "Fantom", "symbol": "FTM", "rank": 67 }, { "id": 2586, "title": "Synthetix", "symbol": "SNX", "rank": 68 }, { "id": 4705, "title": "PAX Gold", "symbol": "PAXG", "rank": 69 }, { "id": 4157, "title": "THORChain", "symbol": "RUNE", "rank": 70 }, { "id": 2694, "title": "Nexo", "symbol": "NEXO", "rank": 71 }, { "id": 8e3, "title": "Lido DAO", "symbol": "LDO", "rank": 72 }, { "id": 6538, "title": "Curve DAO Token", "symbol": "CRV", "rank": 73 }, { "id": 4269, "title": "GateToken", "symbol": "GT", "rank": 74 }, { "id": 131, "title": "Dash", "symbol": "DASH", "rank": 75 }, { "id": 2130, "title": "Enjin Coin", "symbol": "ENJ", "rank": 76 }, { "id": 1697, "title": "Basic Attention Token", "symbol": "BAT", "rank": 77 }, { "id": 5692, "title": "Compound", "symbol": "COMP", "rank": 78 }, { "id": 4847, "title": "Stacks", "symbol": "STX", "rank": 79 }, { "id": 4846, "title": "Kava", "symbol": "KAVA", "rank": 80 }, { "id": 2577, "title": "Ravencoin", "symbol": "RVN", "rank": 81 }, { "id": 2469, "title": "Zilliqa", "symbol": "ZIL", "rank": 82 }, { "id": 1274, "title": "Waves", "symbol": "WAVES", "rank": 83 }, { "id": 8642, "title": "Fei USD", "symbol": "FEI", "rank": 84 }, { "id": 8646, "title": "Mina", "symbol": "MINA", "rank": 85 }, { "id": 3964, "title": "Reserve Rights", "symbol": "RSR", "rank": 86 }, { "id": 2634, "title": "XDC Network", "symbol": "XDC", "rank": 87 }, { "id": 1934, "title": "Loopring", "symbol": "LRC", "rank": 88 }, { "id": 18069, "title": "STEPN", "symbol": "GMT", "rank": 89 }, { "id": 1168, "title": "Decred", "symbol": "DCR", "rank": 90 }, { "id": 5964, "title": "Trust Wallet Token", "symbol": "TWT", "rank": 91 }, { "id": 5567, "title": "Celo", "symbol": "CELO", "rank": 92 }, { "id": 873, "title": "NEM", "symbol": "XEM", "rank": 93 }, { "id": 2083, "title": "Bitcoin Gold", "symbol": "BTG", "rank": 94 }, { "id": 5034, "title": "Kusama", "symbol": "KSM", "rank": 95 }, { "id": 2682, "title": "Holo", "symbol": "HOT", "rank": 96 }, { "id": 8104, "title": "1inch Network", "symbol": "1INCH", "rank": 97 }, { "id": 2700, "title": "Celsius", "symbol": "CEL", "rank": 98 }, { "id": 9903, "title": "Convex Finance", "symbol": "CVX", "rank": 99 }, { "id": 9891, "title": "BinaryX", "symbol": "BNX", "rank": 100 }, { "id": 5632, "title": "Arweave", "symbol": "AR", "rank": 101 }, { "id": 1659, "title": "Gnosis", "symbol": "GNO", "rank": 102 }, { "id": 20314, "title": "Terra", "symbol": "LUNA", "rank": 103 }, { "id": 7653, "title": "Oasis Network", "symbol": "ROSE", "rank": 104 }, { "id": 13855, "title": "Ethereum Name Service", "symbol": "ENS", "rank": 105 }, { "id": 7129, "title": "TerraClassicUSD", "symbol": "USTC", "rank": 106 }, { "id": 3306, "title": "Gemini Dollar", "symbol": "GUSD", "rank": 107 }, { "id": 1684, "title": "Qtum", "symbol": "QTUM", "rank": 108 }, { "id": 5864, "title": "yearn.finance", "symbol": "YFI", "rank": 109 }, { "id": 3783, "title": "Ankr", "symbol": "ANKR", "rank": 110 }, { "id": 3822, "title": "Theta Fuel", "symbol": "TFUEL", "rank": 111 }, { "id": 7080, "title": "Gala", "symbol": "GALA", "rank": 112 }, { "id": 1455, "title": "Golem", "symbol": "GLM", "rank": 113 }, { "id": 2777, "title": "IoTeX", "symbol": "IOTX", "rank": 114 }, { "id": 5647, "title": "Kadena", "symbol": "KDA", "rank": 115 }, { "id": 11584, "title": "Braintrust", "symbol": "BTRST", "rank": 116 }, { "id": 3945, "title": "Harmony", "symbol": "ONE", "rank": 117 }, { "id": 1808, "title": "OMG Network", "symbol": "OMG", "rank": 118 }, { "id": 5728, "title": "Balancer", "symbol": "BAL", "rank": 119 }, { "id": 1896, "title": "0x", "symbol": "ZRX", "rank": 120 }, { "id": 3640, "title": "Livepeer", "symbol": "LPT", "rank": 121 }, { "id": 2496, "title": "Polymath", "symbol": "POLY", "rank": 122 }, { "id": 5488, "title": "JUST", "symbol": "JST", "rank": 123 }, { "id": 3029, "title": "Flux", "symbol": "FLUX", "rank": 124 }, { "id": 2099, "title": "ICON", "symbol": "ICX", "rank": 125 }, { "id": 3801, "title": "BORA", "symbol": "BORA", "rank": 126 }, { "id": 2405, "title": "IOST", "symbol": "IOST", "rank": 127 }, { "id": 5370, "title": "Hive", "symbol": "HIVE", "rank": 128 }, { "id": 6945, "title": "Amp", "symbol": "AMP", "rank": 129 }, { "id": 11840, "title": "Optimism", "symbol": "OP", "rank": 130 }, { "id": 9444, "title": "Kyber Network Crystal v2", "symbol": "KNC", "rank": 131 }, { "id": 8677, "title": "Symbol", "symbol": "XYM", "rank": 132 }, { "id": 6187, "title": "Serum", "symbol": "SRM", "rank": 133 }, { "id": 2566, "title": "Ontology", "symbol": "ONT", "rank": 134 }, { "id": 2300, "title": "WAX", "symbol": "WAXP", "rank": 135 }, { "id": 1772, "title": "Storj", "symbol": "STORJ", "rank": 136 }, { "id": 3628, "title": "MXC", "symbol": "MXC", "rank": 137 }, { "id": 5899, "title": "Casper", "symbol": "CSPR", "rank": 138 }, { "id": 10603, "title": "Immutable X", "symbol": "IMX", "rank": 139 }, { "id": 1042, "title": "Siacoin", "symbol": "SC", "rank": 140 }, { "id": 1698, "title": "Horizen", "symbol": "ZEN", "rank": 141 }, { "id": 7455, "title": "Audius", "symbol": "AUDIO", "rank": 142 }, { "id": 6836, "title": "Moonbeam", "symbol": "GLMR", "rank": 143 }, { "id": 4279, "title": "SXP", "symbol": "SXP", "rank": 144 }, { "id": 9258, "title": "Chia", "symbol": "XCH", "rank": 145 }, { "id": 3437, "title": "ABBC Coin", "symbol": "ABBC", "rank": 146 }, { "id": 2499, "title": "SwissBorg", "symbol": "CHSB", "rank": 147 }, { "id": 1817, "title": "Voyager Token", "symbol": "VGX", "rank": 148 }, { "id": 5617, "title": "UMA", "symbol": "UMA", "rank": 149 }, { "id": 7501, "title": "WOO Network", "symbol": "WOO", "rank": 150 }].reduce((o2, v) => {
          o2[v.symbol] = Object.assign(Object.assign({}, o2), { logo: `https://s2.coinmarketcap.com/static/img/coins/128x128/${v.id}.png` });
          return o2;
        }, {});
        this.data = {
          "crypto": {
            last_updated: null,
            current: null
          },
          "fiat": {
            last_updated: null,
            current: null
          }
        };
        this.options = Object.assign({ cryptoInterval: helpers_12.isBrowser ? 15 * 1e3 : 5 * 1e3, fiatInterval: 60 * 1e3 * 60, calculateAverage: true, onUpdate: void 0, serverHost: "https://api.coinconvert.net", useHostedAPI: false, refreshCryptoList: true, listLimit: 150, disableExchangeMode: "saveLastCache" }, this.exchanges.reduce((o2, exchange) => Object.assign(Object.assign({}, o2), { [exchange]: true }), {}));
        this.isReady = false;
        this.isRunning = false;
        if (o) {
          this.setOptions(o);
        }
        if (!this.hostedAPI) {
          this.hostedAPI = new api_1.default.coinconvert({
            $options: {
              base: this.options.serverHost
            }
          });
        }
      }
      log(..._) {
        var _a, _b;
        if (!helpers_12.isBrowser && ((_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) === null || _b === void 0 ? void 0 : _b.startsWith("dev"))) {
          Array.from(arguments).forEach((arg) => {
            console.log(arg);
          });
        }
      }
      /**
       * Options
       */
      setOptions(o) {
        let newOptions = typeof o === "function" ? o(Object.assign({}, this.options)) : o || {};
        if (helpers_12.isBrowser && !isNaN(newOptions.cryptoInterval) && newOptions.cryptoInterval < 1e4) {
          console.error(`The minimum allowed interval on frontend is 10s. You should host your own server API if you want to go lower.
			
			For the server API routes see the CoinConvert schema on https://github.com/coinconvert/crypto-convert/blob/main/src/api.ts;
			`);
        }
        let exchangesUpdated = false, averageUpdated = newOptions.hasOwnProperty("calculateAverage") && newOptions.calculateAverage !== this.options.calculateAverage, disabledExchangesModeUpdated = newOptions["disableExchangeMode"] === "saveAllCache" && this.options.disableExchangeMode !== "saveAllCache";
        for (const exchange of this.exchanges) {
          if (newOptions.hasOwnProperty(exchange) && newOptions[exchange] !== this.options[exchange]) {
            exchangesUpdated = true;
            break;
          }
        }
        if (newOptions.hasOwnProperty("HTTPAgent")) {
          api_1.default.set({
            $options: {
              fetch_agent: newOptions.HTTPAgent
            }
          });
        }
        if (newOptions.serverHost && (0, helpers_12.isValidUrl)(newOptions.serverHost)) {
          this.options.serverHost = newOptions.serverHost;
          this.hostedAPI = new api_1.default.coinconvert({
            $options: {
              base: newOptions.serverHost
            }
          });
        }
        this.options = Object.assign(Object.assign(Object.assign({}, this.options), newOptions), {
          /**
           * Minimum interval set to 1s on Node.js and 10s on Browsers.
           * You can go up to 1s on browsers if you have set a custom server host.
           */
          cryptoInterval: isNaN(newOptions.cryptoInterval) ? this.options.cryptoInterval : Math.max(helpers_12.isBrowser && !this.isCustomServerHost ? 1e4 : 1e3, newOptions.cryptoInterval),
          fiatInterval: isNaN(newOptions.fiatInterval) ? this.options.fiatInterval : Math.max(60 * 30 * 1e3, newOptions.fiatInterval),
          /**
           * Maximum 1000
           * If the limit is too high, it might cause some memory and performance issues.
           */
          listLimit: isNaN(newOptions.listLimit) ? this.options.listLimit : Math.max(1, Math.min(1e3, parseInt(newOptions.listLimit + "")))
        });
        if ((exchangesUpdated || averageUpdated) && this.isReady) {
          if (helpers_12.isBrowser || this.options.useHostedAPI) {
            return this.browserTicker();
          } else {
            if (this.options.disableExchangeMode === "noCache" || disabledExchangesModeUpdated) {
              return this.updateCrypto();
            }
            this.data.crypto.current = this.joinPrices(this.data);
          }
        }
        return this;
      }
      get isCustomServerHost() {
        return !/^https?:\/\/api\.coinconvert\.net/i.test(this.options.serverHost);
      }
      updateCrypto() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.data.crypto.last_updated) {
            this.log("Updating crypto...");
          }
          const tickers = this.exchanges.reduce((o, exchange) => Object.assign(Object.assign({}, o), { [exchange]: api_1.default[exchange].ticker }), {});
          let currents = [], current = {};
          for (const ticker in tickers) {
            if (!this.options[ticker] && this.options.disableExchangeMode !== "saveAllCache") {
              continue;
            }
            try {
              this.data.crypto[ticker] = yield tickers[ticker]();
              if (this.options[ticker]) {
                currents.push(this.data.crypto[ticker]);
                current = Object.assign(Object.assign({}, current), this.data.crypto[ticker]);
                this.data.crypto.last_updated = +/* @__PURE__ */ new Date();
              }
            } catch (err) {
              this.data.crypto[ticker] = null;
              console.error(`Failed fetching prices from ${ticker}`, err);
            }
          }
          if (currents.length) {
            this.data.crypto.current = this.options.calculateAverage ? Object.assign(Object.assign({}, current), (0, helpers_12.getAverage)(currents)) : current;
            if (typeof this.options.onUpdate === "function") {
              this.options.onUpdate(this.data.crypto);
            }
          }
          return this;
        });
      }
      updateFiat() {
        return __awaiter2(this, void 0, void 0, function* () {
          this.log("Updating fiat...");
          try {
            this.data.fiat.current = yield api_1.default.fiat.all();
            this.data.fiat.last_updated = +/* @__PURE__ */ new Date();
            if (typeof this.options.onUpdate === "function") {
              this.options.onUpdate(this.data.fiat, true);
            }
          } catch (err) {
            console.error(`Failed fetching fiat prices from ECB`, err);
          }
          return this;
        });
      }
      updateLists() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.data.crypto.last_updated) {
            this.log("Updating top currency list...");
          }
          try {
            const getTopList = yield api_1.default.coinmarketcap.top({
              limit: this.options.listLimit + ""
            });
            this.list.crypto = Object.keys(getTopList);
            this.cryptoInfo = getTopList;
            if (typeof this.onCryptoListRefresh == "function" && this.isReady) {
              this.onCryptoListRefresh(this.list.crypto);
            }
          } catch (err) {
            console.error(`Failed fetching fiat prices from ECB`, err);
          }
          return this;
        });
      }
      joinPrices(data) {
        const exchangesData = this.exchanges.reduce((o, exchange) => Object.assign(Object.assign({}, o), { [exchange]: data.crypto[exchange] }), {});
        let currents = [], current = {};
        for (const exchange in exchangesData) {
          if (!this.options[exchange] || !exchangesData[exchange]) {
            continue;
          }
          currents.push(exchangesData[exchange]);
          current = Object.assign(Object.assign({}, current), exchangesData[exchange]);
        }
        return this.options.calculateAverage ? Object.assign(Object.assign({}, current), (0, helpers_12.getAverage)(currents)) : current;
      }
      browserTicker() {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            const currentOptions = this.options;
            const disabledExchanges = this.exchanges.filter((exchange) => !currentOptions[exchange]);
            const data = yield this.hostedAPI.ticker(disabledExchanges.length ? {
              "filterExchanges": disabledExchanges,
              "noAverage": !this.options.calculateAverage ? true : void 0
            } : {});
            this.data = data;
            if (typeof this.options.onUpdate === "function") {
              this.options.onUpdate(this.data);
            }
          } catch (err) {
            console.error(`Failed fetching prices from API`, err);
          }
          return this;
        });
      }
      browserLists() {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            const getTopList = yield this.hostedAPI.list();
            this.list.crypto = Object.keys(getTopList.crypto);
            this.list.fiat = getTopList.fiat;
            this.cryptoInfo = getTopList.crypto;
            if (typeof this.onCryptoListRefresh == "function" && this.isReady) {
              this.onCryptoListRefresh(this.list.crypto);
            }
          } catch (err) {
            console.error("Failed fetching currencies list from API", err);
          }
          return this;
        });
      }
      runBrowser() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof window !== "undefined" && window["__ccRunning"]) {
            throw new Error(`The crypto-convert worker seems to be already running. 
			- There might be an issue with the way your app imports javascript dependencies. 
			- Make sure to call 'convert.stop()' on component unmounts if you are using SPA frameworks (e.g React).`);
          }
          if (!this.isReady) {
            yield this.browserTicker();
            yield this.browserLists();
            if (!this.isRunning) {
              return false;
            }
            if (!helpers_12.isBrowser && this.options.useHostedAPI && this.options.refreshCryptoList) {
              this.lists_worker = setInterval(
                this.browserLists.bind(this),
                86400
                //every day
              );
            }
          }
          this.crypto_worker = setInterval(this.browserTicker.bind(this), this.options.cryptoInterval);
          this.isReady = true;
          if (typeof window !== "undefined") {
            window["__ccRunning"] = true;
            if (window["__ccRunID"]) {
              clearInterval(window["__ccRunID"]);
            }
            window["__ccRunID"] = this.crypto_worker;
          }
          return this;
        });
      }
      runServer() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.updateLists();
          yield this.updateFiat();
          yield this.updateCrypto();
          if (!this.isRunning) {
            return false;
          }
          this.isReady = true;
          this.crypto_worker = setInterval(this.updateCrypto.bind(this), this.options.cryptoInterval);
          this.fiat_worker = setInterval(this.updateFiat.bind(this), this.options.fiatInterval);
          if (this.options.refreshCryptoList) {
            this.lists_worker = setInterval(
              this.updateLists.bind(this),
              86400
              //every day
            );
          }
          return this;
        });
      }
      run() {
        if (this.isRunning || this.crypto_worker) {
          throw new Error("Crypto-convert is already running.");
        }
        this.isRunning = true;
        if (helpers_12.isBrowser || this.options.useHostedAPI) {
          return this.runBrowser();
        }
        return this.runServer();
      }
      stop() {
        this.isRunning = false;
        clearInterval(this.crypto_worker);
        clearInterval(this.fiat_worker);
        this.crypto_worker = null;
        this.fiat_worker = null;
        if (this.lists_worker) {
          clearInterval(this.lists_worker);
          this.lists_worker = null;
        }
        if (typeof window !== "undefined") {
          window["__ccRunning"] = false;
        }
        return this;
      }
      restart() {
        return this.stop().run();
      }
    };
    exports2.default = PricesWorker;
  }
});

// node_modules/crypto-convert/dist/custom.js
var require_custom = __commonJS({
  "node_modules/crypto-convert/dist/custom.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var worker_12 = require_worker();
    var CustomWorkers = class {
      constructor() {
        this.ticker = {};
        this.list = [];
        this.workers = {};
        this.workersPromises = [];
      }
      ready() {
        return __awaiter2(this, void 0, void 0, function* () {
          return Promise.all(this.workersPromises);
        });
      }
      addCurrency(base, quote, getter, interval) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof base !== "string" || typeof quote !== "string" || !worker_12.initialCoinList.fiat.includes(quote)) {
            throw new Error("Invalid currency pair.");
          }
          if (typeof getter !== "function") {
            throw new Error("No function specified.");
          }
          base = base.toUpperCase(), quote = quote.toUpperCase();
          if (this.ticker[base + quote] || this.ticker[quote + base] || this.list.indexOf(base) != -1) {
            console.warn(`This custom currency already exists, it will be overriden.`);
            this.removeCurrency(base);
          }
          this.list.push(base);
          if (interval) {
            if (typeof interval !== "number") {
              throw new Error("Invalid interval specfied.");
            }
            this.workers[base + quote] = setInterval(() => {
              return Promise.resolve(getter()).then((value) => {
                this.ticker[base + quote] = Number(value);
              });
            }, interval);
          }
          const currentPromise = Promise.resolve(getter()).then((value) => {
            this.ticker[base + quote] = Number(value);
          });
          this.workersPromises.push(currentPromise);
          return currentPromise;
        });
      }
      removeCurrency(base, quote) {
        base = base.toUpperCase(), quote = quote ? quote.toUpperCase() : "";
        for (const worker in this.workers) {
          if (worker.includes(base + quote)) {
            clearInterval(this.workers[worker]);
            delete this.ticker[worker];
          }
        }
        this.list = this.list.filter((v) => v !== base);
      }
    };
    exports2.default = CustomWorkers;
  }
});

// node_modules/crypto-convert/dist/index.js
var require_dist = __commonJS({
  "node_modules/crypto-convert/dist/index.js"(exports, module) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _CryptoConvert_instances;
    var _CryptoConvert_getPrice;
    var _CryptoConvert_wrapper;
    var _CryptoConvert_isSafeKey;
    var _CryptoConvert_setExtendedOptions;
    var _CryptoConvert_populate;
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_helpers();
    var worker_1 = __importDefault(require_worker());
    var custom_1 = __importDefault(require_custom());
    var customWorkers = new custom_1.default();
    var CryptoConvert = class _CryptoConvert {
      constructor(options = {}) {
        _CryptoConvert_instances.add(this);
        this.precision = {
          fiat: 4,
          crypto: 8
        };
        if (helpers_1.isBrowser) {
          if (window["__ccInitialized"]) {
            throw new Error("You have already initalized one instance of crypto-convert. You cannot initialize multiple instances.");
          }
          window["__ccInitialized"] = true;
        }
        __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_setExtendedOptions).call(this, options);
        this.worker = new worker_1.default(options);
        this.workerReady = this.worker.run();
        this.internalMethods = Object.getOwnPropertyNames(_CryptoConvert.prototype);
        Promise.resolve(this.workerReady).then(() => {
          __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_populate).call(this);
          this.worker.onCryptoListRefresh = () => {
            __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_populate).call(this);
          };
        });
      }
      /**
       * Quick check if cache has loaded.
       */
      get isReady() {
        return this.worker.isReady;
      }
      /**
       * Supported currencies list
       */
      get list() {
        return {
          "crypto": this.worker.list.crypto.concat(customWorkers.list),
          "fiat": this.worker.list.fiat
        };
      }
      /**
       * Metadata information about cryptocurrencies
       */
      get cryptoInfo() {
        return this.worker.cryptoInfo;
      }
      /**
       * Get crypto prices last updated ms
       */
      get lastUpdated() {
        return this.worker.data.crypto.last_updated;
      }
      /**
       * Price Tickers
       */
      get ticker() {
        return this.worker.data;
      }
      /**
       * Update options
       */
      setOptions(options) {
        __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_setExtendedOptions).call(this, options);
        const workerIntervalChanged = (options.cryptoInterval || options.fiatInterval) && (options.cryptoInterval !== this.worker.options.cryptoInterval || options.fiatInterval !== this.worker.options.fiatInterval);
        if (workerIntervalChanged || options.hasOwnProperty("refreshCryptoList") && options.refreshCryptoList !== this.worker.options.refreshCryptoList || options.hasOwnProperty("useHostedAPI") && options.useHostedAPI !== this.worker.options.useHostedAPI || options.listLimit && options.listLimit != this.worker.options.listLimit) {
          if (!this.worker.isReady) {
            throw new Error("You cannot set these options here because CryptoConvert is not ready yet. Instead set the options on the constructor parameter.");
          }
          this.workerReady = Promise.resolve(this.worker.setOptions(options)).then(() => __awaiter(this, void 0, void 0, function* () {
            yield this.worker.restart();
            if (options.listLimit) {
              __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_populate).call(this);
            }
            return this.worker;
          }));
          return this.worker;
        }
        return this.worker.setOptions(options);
      }
      /**
       * Stop the worker.
       *
       * It's recommended to do this on Component unmounts (i.e if you are using React).
       */
      stop() {
        return this.worker.stop();
      }
      /**
       * Re-start the worker when it has been stopped.
       */
      restart() {
        this.workerReady = this.worker.restart();
        return this.workerReady;
      }
      /**
       * Promise function that resolves when cache has loaded.
       */
      ready() {
        return __awaiter(this, void 0, void 0, function* () {
          yield Promise.resolve(this.workerReady);
          yield Promise.resolve(customWorkers.ready());
          return this;
        });
      }
      /**
       * Add a custom currency fetcher. Can be anything.
       *
       * @example
       * ```javascript
       * convert.addCurrency('ANY','USD', async fetchPrice()=>{
       * 		//...call your api here
       * 		return price;
       * }, 10000);
       * ```
       */
      addCurrency(base, ...rest) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.hasOwnProperty(base)) {
            throw new Error("This property already exists.");
          }
          return Promise.resolve(customWorkers.addCurrency.apply(customWorkers, [base, ...rest])).then(() => {
            if (this.worker.isReady) {
              __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_populate).call(this);
            }
          });
        });
      }
      /**
       * Remove custom currency fetcher.
       */
      removeCurrency(base, quote) {
        var _a, _b;
        if (customWorkers.list.includes(base) && __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_isSafeKey).call(this, base)) {
          delete this[base];
          const all_currencies2 = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);
          for (const currency2 of all_currencies2) {
            if ((_a = this[currency2]) === null || _a === void 0 ? void 0 : _a[base]) {
              (_b = this[currency2]) === null || _b === void 0 ? true : delete _b[base];
            }
          }
        }
        return customWorkers.removeCurrency(base, quote);
      }
    };
    _CryptoConvert_instances = /* @__PURE__ */ new WeakSet(), _CryptoConvert_getPrice = function _CryptoConvert_getPrice2(coin2, to = "USD") {
      var customResult = customWorkers.ticker[coin2 + to] || (customWorkers.ticker[to + coin2] ? 1 / customWorkers.ticker[to + coin2] : null);
      var result = this.worker.data.crypto.current[coin2 + to] || (this.worker.data.crypto.current[to + coin2] ? 1 / this.worker.data.crypto.current[to + coin2] : null);
      return customResult || result;
    }, _CryptoConvert_wrapper = function _CryptoConvert_wrapper2(coin2, currency2) {
      var coin2 = coin2;
      var toCurrency = currency2;
      const doExchange = (function(fromAmount) {
        if ((0, helpers_1.isEmpty)(this.worker.data.crypto.current) || (0, helpers_1.isEmpty)(this.worker.data.fiat.current)) {
          console.warn("[~] Prices are loading.\nYou should use `await convert.ready()` to make sure prices are loaded before calling convert.");
          return false;
        }
        if (!fromAmount) {
          return false;
        }
        fromAmount = (0, helpers_1.formatNumber)(fromAmount);
        if (isNaN(fromAmount)) {
          return false;
        }
        const fiatCurrencies = this.worker.data.fiat.current;
        const cryptoCurrenciesList = this.worker.list.crypto.concat(customWorkers.list);
        if (toCurrency == coin2) {
          return fromAmount;
        }
        if (cryptoCurrenciesList.includes(coin2) && cryptoCurrenciesList.includes(toCurrency)) {
          let exchangePrice = __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_getPrice).call(this, coin2, toCurrency) || __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_wrapper2).call(this, "USD", toCurrency)(__classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_wrapper2).call(this, coin2, "USD")(1));
          return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);
        }
        if (fiatCurrencies[coin2] && fiatCurrencies[toCurrency]) {
          return (0, helpers_1.formatNumber)(fromAmount / fiatCurrencies[coin2] * fiatCurrencies[toCurrency], this.precision.fiat);
        }
        var getCryptoPrice = (function(coin3) {
          var coinPrice = __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_getPrice).call(this, coin3) || __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_wrapper2).call(this, "BTC", "USD")(__classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_getPrice).call(this, coin3, "BTC")) || __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_wrapper2).call(this, "ETH", "USD")(__classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_getPrice).call(this, coin3, "ETH"));
          return coinPrice;
        }).bind(this);
        if (fiatCurrencies[toCurrency]) {
          let usdPrice = getCryptoPrice(coin2);
          let exchangePrice = usdPrice / fiatCurrencies["USD"] * fiatCurrencies[toCurrency];
          return (0, helpers_1.formatNumber)(exchangePrice * fromAmount, this.precision.crypto);
        }
        if (fiatCurrencies[coin2]) {
          let usdPrice = getCryptoPrice(toCurrency);
          let exchangePrice = usdPrice / fiatCurrencies["USD"] * fiatCurrencies[coin2];
          return (0, helpers_1.formatNumber)(fromAmount / exchangePrice, this.precision.crypto);
        }
        return null;
      }).bind(this);
      return doExchange;
    }, _CryptoConvert_isSafeKey = function _CryptoConvert_isSafeKey2(key) {
      const functionProto = function() {
      };
      return !this.internalMethods.includes(key) && !key.startsWith("__") && !functionProto[key];
    }, _CryptoConvert_setExtendedOptions = function _CryptoConvert_setExtendedOptions2(options) {
      if (options.precision) {
        for (const precisionKey in options.precision) {
          if (["crypto", "fiat"].includes(precisionKey) && typeof options.precision[precisionKey] == "number") {
            this.precision[precisionKey] = options.precision[precisionKey];
          }
        }
      }
    }, _CryptoConvert_populate = function _CryptoConvert_populate() {
      let types = "";
      types += `type amount = (amount: number | string) => number | false | null;`;
      types += "\nexport interface Pairs {";
      const all_currencies = this.worker.list.crypto.concat(this.worker.list.fiat, customWorkers.list);
      for (var i = 0; i < all_currencies.length; i++) {
        var coin = all_currencies[i];
        if (!coin || typeof coin !== "string" || !__classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_isSafeKey).call(this, coin)) {
          continue;
        }
        if (!this[coin]) {
          this[coin] = {};
        }
        types += `
	'${coin.replace(/\'/g, "\\'")}': {`;
        for (var a = 0; a < all_currencies.length; a++) {
          var currency = all_currencies[a];
          if (!currency || typeof currency !== "string" || !__classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_isSafeKey).call(this, coin)) {
            continue;
          }
          this[coin][currency] = __classPrivateFieldGet(this, _CryptoConvert_instances, "m", _CryptoConvert_wrapper).call(this, coin, currency);
          types += `
		'${currency.replace(/\'/g, "\\'")}': amount,`;
        }
        types += "\n},";
      }
      types += "\n}";
      if (typeof window === "undefined" && typeof module !== "undefined" && typeof process !== "undefined") {
        (function() {
          return __awaiter(this, void 0, void 0, function* () {
            try {
              eval(`
						const fs = require('fs');
						const path = require('path');
						const isDist = path.basename(__dirname) == 'dist';
						const typesFile = path.join(__dirname, isDist ? 'paris.d.ts' : 'paris.ts');

						fs.writeFileSync(typesFile, types, 'utf-8');
					`);
            } catch (err) {
              console.warn(err);
            }
          });
        })();
      }
    };
    CryptoConvert.default = CryptoConvert;
    if (typeof module !== "undefined" && module.exports) {
      module.exports = CryptoConvert;
    }
    exports.default = CryptoConvert;
  }
});
export default require_dist();
/*! Bundled license information:

crypto-convert/dist/index.js:
  (*!
   * crypto-convert (c) 2022
   * Author: Elis
   * License: https://github.com/coinconvert/crypto-convert
   *)
*/
//# sourceMappingURL=crypto-convert.js.map
