"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialCoinList = void 0;
const api_1 = __importDefault(require("./api"));
const helpers_1 = require("./helpers");
exports.initialCoinList = {
    "crypto": [
        "BTC", "ETH", "USDT", "USDC", "BNB", "XRP", "BUSD", "ADA", "SOL", "DOGE", "DOT", "DAI", "MATIC", "SHIB", "TRX", "AVAX", "UNI", "WBTC", "LEO", "LTC", "ETC", "LINK", "ATOM", "FTT", "XLM", "NEAR", "CRO", "XMR", "ALGO", "BCH", "LUNC", "FLOW", "QNT", "VET", "TON", "FIL", "APE", "ICP", "CHZ", "HBAR", "MANA", "XTZ", "SAND", "EOS", "EGLD", "THETA", "AAVE", "AXS", "OKB", "USDP", "BSV", "KCS", "TUSD", "ZEC", "MIOTA", "XEC", "USDD", "MKR", "BTT", "HT", "GRT", "USDN", "HNT", "CAKE", "NEO", "KLAY", "FTM", "SNX", "PAXG", "RUNE", "NEXO", "LDO", "CRV", "GT", "DASH", "ENJ", "BAT", "COMP", "STX", "KAVA", "RVN", "ZIL", "WAVES", "FEI", "MINA", "RSR", "XDC", "LRC", "GMT", "DCR", "TWT", "CELO", "XEM", "BTG", "KSM", "HOT", "1INCH", "CEL", "CVX", "BNX", "AR", "GNO", "LUNA", "ROSE", "ENS", "USTC", "GUSD", "QTUM", "YFI", "ANKR", "TFUEL", "GALA", "GLM", "IOTX", "KDA", "BTRST", "ONE", "OMG", "BAL", "ZRX", "LPT", "POLY", "JST", "FLUX", "ICX", "BORA", "IOST", "HIVE", "AMP", "OP", "KNC", "XYM", "SRM", "ONT", "WAXP", "STORJ", "MXC", "CSPR", "IMX", "SC", "ZEN", "AUDIO", "GLMR", "SXP", "XCH", "ABBC", "CHSB", "VGX", "UMA", "WOO"
    ],
    "fiat": [
        "USD", "JPY", "BGN", "CZK", "DKK", "GBP", "HUF", "PLN", "RON", "SEK", "CHF", "ISK", "NOK", "HRK", "RUB", "TRY", "AUD", "BRL", "CAD", "CNY", "HKD", "IDR", "ILS", "INR", "KRW", "MXN", "MYR", "NZD", "PHP", "SGD", "THB", "ZAR", "EUR"
    ]
};
class PricesWorker {
    constructor(o) {
        this.exchanges = ['binance', 'bitfinex', 'coinbase', 'kraken'];
        this.list = exports.initialCoinList;
        this.cryptoInfo = [{ "id": 1, "title": "Bitcoin", "symbol": "BTC", "rank": 1 }, { "id": 1027, "title": "Ethereum", "symbol": "ETH", "rank": 2 }, { "id": 825, "title": "Tether", "symbol": "USDT", "rank": 3 }, { "id": 3408, "title": "USD Coin", "symbol": "USDC", "rank": 4 }, { "id": 1839, "title": "BNB", "symbol": "BNB", "rank": 5 }, { "id": 52, "title": "XRP", "symbol": "XRP", "rank": 6 }, { "id": 4687, "title": "Binance USD", "symbol": "BUSD", "rank": 7 }, { "id": 2010, "title": "Cardano", "symbol": "ADA", "rank": 8 }, { "id": 5426, "title": "Solana", "symbol": "SOL", "rank": 9 }, { "id": 74, "title": "Dogecoin", "symbol": "DOGE", "rank": 10 }, { "id": 6636, "title": "Polkadot", "symbol": "DOT", "rank": 11 }, { "id": 4943, "title": "Dai", "symbol": "DAI", "rank": 12 }, { "id": 3890, "title": "Polygon", "symbol": "MATIC", "rank": 13 }, { "id": 5994, "title": "Shiba Inu", "symbol": "SHIB", "rank": 14 }, { "id": 1958, "title": "TRON", "symbol": "TRX", "rank": 15 }, { "id": 5805, "title": "Avalanche", "symbol": "AVAX", "rank": 16 }, { "id": 7083, "title": "Uniswap", "symbol": "UNI", "rank": 17 }, { "id": 3717, "title": "Wrapped Bitcoin", "symbol": "WBTC", "rank": 18 }, { "id": 3957, "title": "UNUS SED LEO", "symbol": "LEO", "rank": 19 }, { "id": 2, "title": "Litecoin", "symbol": "LTC", "rank": 20 }, { "id": 1321, "title": "Ethereum Classic", "symbol": "ETC", "rank": 21 }, { "id": 1975, "title": "Chainlink", "symbol": "LINK", "rank": 22 }, { "id": 3794, "title": "Cosmos", "symbol": "ATOM", "rank": 23 }, { "id": 4195, "title": "FTX Token", "symbol": "FTT", "rank": 24 }, { "id": 512, "title": "Stellar", "symbol": "XLM", "rank": 25 }, { "id": 6535, "title": "NEAR Protocol", "symbol": "NEAR", "rank": 26 }, { "id": 3635, "title": "Cronos", "symbol": "CRO", "rank": 27 }, { "id": 328, "title": "Monero", "symbol": "XMR", "rank": 28 }, { "id": 4030, "title": "Algorand", "symbol": "ALGO", "rank": 29 }, { "id": 1831, "title": "Bitcoin Cash", "symbol": "BCH", "rank": 30 }, { "id": 4172, "title": "Terra Classic", "symbol": "LUNC", "rank": 31 }, { "id": 4558, "title": "Flow", "symbol": "FLOW", "rank": 32 }, { "id": 3155, "title": "Quant", "symbol": "QNT", "rank": 33 }, { "id": 3077, "title": "VeChain", "symbol": "VET", "rank": 34 }, { "id": 11419, "title": "Toncoin", "symbol": "TON", "rank": 35 }, { "id": 2280, "title": "Filecoin", "symbol": "FIL", "rank": 36 }, { "id": 18876, "title": "ApeCoin", "symbol": "APE", "rank": 37 }, { "id": 8916, "title": "Internet Computer", "symbol": "ICP", "rank": 38 }, { "id": 4066, "title": "Chiliz", "symbol": "CHZ", "rank": 39 }, { "id": 4642, "title": "Hedera", "symbol": "HBAR", "rank": 40 }, { "id": 1966, "title": "Decentraland", "symbol": "MANA", "rank": 41 }, { "id": 2011, "title": "Tezos", "symbol": "XTZ", "rank": 42 }, { "id": 6210, "title": "The Sandbox", "symbol": "SAND", "rank": 43 }, { "id": 1765, "title": "EOS", "symbol": "EOS", "rank": 44 }, { "id": 6892, "title": "Elrond", "symbol": "EGLD", "rank": 45 }, { "id": 2416, "title": "Theta Network", "symbol": "THETA", "rank": 46 }, { "id": 7278, "title": "Aave", "symbol": "AAVE", "rank": 47 }, { "id": 6783, "title": "Axie Infinity", "symbol": "AXS", "rank": 48 }, { "id": 3897, "title": "OKB", "symbol": "OKB", "rank": 49 }, { "id": 3330, "title": "Pax Dollar", "symbol": "USDP", "rank": 50 }, { "id": 3602, "title": "Bitcoin SV", "symbol": "BSV", "rank": 51 }, { "id": 2087, "title": "KuCoin Token", "symbol": "KCS", "rank": 52 }, { "id": 2563, "title": "TrueUSD", "symbol": "TUSD", "rank": 53 }, { "id": 1437, "title": "Zcash", "symbol": "ZEC", "rank": 54 }, { "id": 1720, "title": "IOTA", "symbol": "MIOTA", "rank": 55 }, { "id": 10791, "title": "eCash", "symbol": "XEC", "rank": 56 }, { "id": 19891, "title": "USDD", "symbol": "USDD", "rank": 57 }, { "id": 1518, "title": "Maker", "symbol": "MKR", "rank": 58 }, { "id": 16086, "title": "BitTorrent-New", "symbol": "BTT", "rank": 59 }, { "id": 2502, "title": "Huobi Token", "symbol": "HT", "rank": 60 }, { "id": 6719, "title": "The Graph", "symbol": "GRT", "rank": 61 }, { "id": 5068, "title": "Neutrino USD", "symbol": "USDN", "rank": 62 }, { "id": 5665, "title": "Helium", "symbol": "HNT", "rank": 63 }, { "id": 7186, "title": "PancakeSwap", "symbol": "CAKE", "rank": 64 }, { "id": 1376, "title": "Neo", "symbol": "NEO", "rank": 65 }, { "id": 4256, "title": "Klaytn", "symbol": "KLAY", "rank": 66 }, { "id": 3513, "title": "Fantom", "symbol": "FTM", "rank": 67 }, { "id": 2586, "title": "Synthetix", "symbol": "SNX", "rank": 68 }, { "id": 4705, "title": "PAX Gold", "symbol": "PAXG", "rank": 69 }, { "id": 4157, "title": "THORChain", "symbol": "RUNE", "rank": 70 }, { "id": 2694, "title": "Nexo", "symbol": "NEXO", "rank": 71 }, { "id": 8000, "title": "Lido DAO", "symbol": "LDO", "rank": 72 }, { "id": 6538, "title": "Curve DAO Token", "symbol": "CRV", "rank": 73 }, { "id": 4269, "title": "GateToken", "symbol": "GT", "rank": 74 }, { "id": 131, "title": "Dash", "symbol": "DASH", "rank": 75 }, { "id": 2130, "title": "Enjin Coin", "symbol": "ENJ", "rank": 76 }, { "id": 1697, "title": "Basic Attention Token", "symbol": "BAT", "rank": 77 }, { "id": 5692, "title": "Compound", "symbol": "COMP", "rank": 78 }, { "id": 4847, "title": "Stacks", "symbol": "STX", "rank": 79 }, { "id": 4846, "title": "Kava", "symbol": "KAVA", "rank": 80 }, { "id": 2577, "title": "Ravencoin", "symbol": "RVN", "rank": 81 }, { "id": 2469, "title": "Zilliqa", "symbol": "ZIL", "rank": 82 }, { "id": 1274, "title": "Waves", "symbol": "WAVES", "rank": 83 }, { "id": 8642, "title": "Fei USD", "symbol": "FEI", "rank": 84 }, { "id": 8646, "title": "Mina", "symbol": "MINA", "rank": 85 }, { "id": 3964, "title": "Reserve Rights", "symbol": "RSR", "rank": 86 }, { "id": 2634, "title": "XDC Network", "symbol": "XDC", "rank": 87 }, { "id": 1934, "title": "Loopring", "symbol": "LRC", "rank": 88 }, { "id": 18069, "title": "STEPN", "symbol": "GMT", "rank": 89 }, { "id": 1168, "title": "Decred", "symbol": "DCR", "rank": 90 }, { "id": 5964, "title": "Trust Wallet Token", "symbol": "TWT", "rank": 91 }, { "id": 5567, "title": "Celo", "symbol": "CELO", "rank": 92 }, { "id": 873, "title": "NEM", "symbol": "XEM", "rank": 93 }, { "id": 2083, "title": "Bitcoin Gold", "symbol": "BTG", "rank": 94 }, { "id": 5034, "title": "Kusama", "symbol": "KSM", "rank": 95 }, { "id": 2682, "title": "Holo", "symbol": "HOT", "rank": 96 }, { "id": 8104, "title": "1inch Network", "symbol": "1INCH", "rank": 97 }, { "id": 2700, "title": "Celsius", "symbol": "CEL", "rank": 98 }, { "id": 9903, "title": "Convex Finance", "symbol": "CVX", "rank": 99 }, { "id": 9891, "title": "BinaryX", "symbol": "BNX", "rank": 100 }, { "id": 5632, "title": "Arweave", "symbol": "AR", "rank": 101 }, { "id": 1659, "title": "Gnosis", "symbol": "GNO", "rank": 102 }, { "id": 20314, "title": "Terra", "symbol": "LUNA", "rank": 103 }, { "id": 7653, "title": "Oasis Network", "symbol": "ROSE", "rank": 104 }, { "id": 13855, "title": "Ethereum Name Service", "symbol": "ENS", "rank": 105 }, { "id": 7129, "title": "TerraClassicUSD", "symbol": "USTC", "rank": 106 }, { "id": 3306, "title": "Gemini Dollar", "symbol": "GUSD", "rank": 107 }, { "id": 1684, "title": "Qtum", "symbol": "QTUM", "rank": 108 }, { "id": 5864, "title": "yearn.finance", "symbol": "YFI", "rank": 109 }, { "id": 3783, "title": "Ankr", "symbol": "ANKR", "rank": 110 }, { "id": 3822, "title": "Theta Fuel", "symbol": "TFUEL", "rank": 111 }, { "id": 7080, "title": "Gala", "symbol": "GALA", "rank": 112 }, { "id": 1455, "title": "Golem", "symbol": "GLM", "rank": 113 }, { "id": 2777, "title": "IoTeX", "symbol": "IOTX", "rank": 114 }, { "id": 5647, "title": "Kadena", "symbol": "KDA", "rank": 115 }, { "id": 11584, "title": "Braintrust", "symbol": "BTRST", "rank": 116 }, { "id": 3945, "title": "Harmony", "symbol": "ONE", "rank": 117 }, { "id": 1808, "title": "OMG Network", "symbol": "OMG", "rank": 118 }, { "id": 5728, "title": "Balancer", "symbol": "BAL", "rank": 119 }, { "id": 1896, "title": "0x", "symbol": "ZRX", "rank": 120 }, { "id": 3640, "title": "Livepeer", "symbol": "LPT", "rank": 121 }, { "id": 2496, "title": "Polymath", "symbol": "POLY", "rank": 122 }, { "id": 5488, "title": "JUST", "symbol": "JST", "rank": 123 }, { "id": 3029, "title": "Flux", "symbol": "FLUX", "rank": 124 }, { "id": 2099, "title": "ICON", "symbol": "ICX", "rank": 125 }, { "id": 3801, "title": "BORA", "symbol": "BORA", "rank": 126 }, { "id": 2405, "title": "IOST", "symbol": "IOST", "rank": 127 }, { "id": 5370, "title": "Hive", "symbol": "HIVE", "rank": 128 }, { "id": 6945, "title": "Amp", "symbol": "AMP", "rank": 129 }, { "id": 11840, "title": "Optimism", "symbol": "OP", "rank": 130 }, { "id": 9444, "title": "Kyber Network Crystal v2", "symbol": "KNC", "rank": 131 }, { "id": 8677, "title": "Symbol", "symbol": "XYM", "rank": 132 }, { "id": 6187, "title": "Serum", "symbol": "SRM", "rank": 133 }, { "id": 2566, "title": "Ontology", "symbol": "ONT", "rank": 134 }, { "id": 2300, "title": "WAX", "symbol": "WAXP", "rank": 135 }, { "id": 1772, "title": "Storj", "symbol": "STORJ", "rank": 136 }, { "id": 3628, "title": "MXC", "symbol": "MXC", "rank": 137 }, { "id": 5899, "title": "Casper", "symbol": "CSPR", "rank": 138 }, { "id": 10603, "title": "Immutable X", "symbol": "IMX", "rank": 139 }, { "id": 1042, "title": "Siacoin", "symbol": "SC", "rank": 140 }, { "id": 1698, "title": "Horizen", "symbol": "ZEN", "rank": 141 }, { "id": 7455, "title": "Audius", "symbol": "AUDIO", "rank": 142 }, { "id": 6836, "title": "Moonbeam", "symbol": "GLMR", "rank": 143 }, { "id": 4279, "title": "SXP", "symbol": "SXP", "rank": 144 }, { "id": 9258, "title": "Chia", "symbol": "XCH", "rank": 145 }, { "id": 3437, "title": "ABBC Coin", "symbol": "ABBC", "rank": 146 }, { "id": 2499, "title": "SwissBorg", "symbol": "CHSB", "rank": 147 }, { "id": 1817, "title": "Voyager Token", "symbol": "VGX", "rank": 148 }, { "id": 5617, "title": "UMA", "symbol": "UMA", "rank": 149 }, { "id": 7501, "title": "WOO Network", "symbol": "WOO", "rank": 150 }]
            .reduce((o, v) => {
            o[v.symbol] = Object.assign(Object.assign({}, o), { logo: `https://s2.coinmarketcap.com/static/img/coins/128x128/${v.id}.png` });
            return o;
        }, {});
        this.data = {
            "crypto": {
                last_updated: null,
                current: null
            },
            "fiat": {
                last_updated: null,
                current: null
            }
        };
        this.options = Object.assign({ cryptoInterval: helpers_1.isBrowser ? 15 * 1e3 : (5 * 1e3), fiatInterval: (60 * 1e3 * 60), calculateAverage: true, onUpdate: undefined, serverHost: 'https://api.coinconvert.net', useHostedAPI: false, refreshCryptoList: true, listLimit: 150, disableExchangeMode: "saveLastCache" }, (this.exchanges.reduce((o, exchange) => (Object.assign(Object.assign({}, o), { [exchange]: true })), {})));
        this.isReady = false;
        this.isRunning = false;
        if (o) {
            this.setOptions(o);
        }
        if (!this.hostedAPI) {
            this.hostedAPI = new api_1.default.coinconvert({
                $options: {
                    base: this.options.serverHost
                }
            });
        }
    }
    log(..._) {
        var _a, _b;
        if (!helpers_1.isBrowser && ((_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) === null || _b === void 0 ? void 0 : _b.startsWith('dev'))) {
            Array.from(arguments).forEach((arg) => {
                console.log(arg);
            });
        }
    }
    /**
     * Options
     */
    setOptions(o) {
        let newOptions = typeof o === "function" ?
            o(Object.assign({}, this.options)) :
            (o || {});
        if (helpers_1.isBrowser && !isNaN(newOptions.cryptoInterval) && newOptions.cryptoInterval < 10000) {
            console.error(`The minimum allowed interval on frontend is 10s. You should host your own server API if you want to go lower.
			
			For the server API routes see the CoinConvert schema on https://github.com/coinconvert/crypto-convert/blob/main/src/api.ts;
			`);
        }
        //Check if new options affect prices
        let exchangesUpdated = false, averageUpdated = newOptions.hasOwnProperty('calculateAverage') && newOptions.calculateAverage !== this.options.calculateAverage, disabledExchangesModeUpdated = newOptions['disableExchangeMode'] === 'saveAllCache' && this.options.disableExchangeMode !== 'saveAllCache';
        for (const exchange of this.exchanges) {
            if (newOptions.hasOwnProperty(exchange) && newOptions[exchange] !== this.options[exchange]) {
                exchangesUpdated = true;
                break;
            }
        }
        //Save options
        if (newOptions.hasOwnProperty('HTTPAgent')) {
            api_1.default.set({
                $options: {
                    fetch_agent: newOptions.HTTPAgent
                }
            });
        }
        if (newOptions.serverHost && (0, helpers_1.isValidUrl)(newOptions.serverHost)) {
            this.options.serverHost = newOptions.serverHost;
            this.hostedAPI = new api_1.default.coinconvert({
                $options: {
                    base: newOptions.serverHost
                }
            });
        }
        this.options = Object.assign(Object.assign(Object.assign({}, this.options), newOptions), { 
            /**
             * Minimum interval set to 1s on Node.js and 10s on Browsers.
             * You can go up to 1s on browsers if you have set a custom server host.
             */
            cryptoInterval: isNaN(newOptions.cryptoInterval) ?
                this.options.cryptoInterval :
                Math.max(helpers_1.isBrowser && !this.isCustomServerHost ? 10000 : 1000, newOptions.cryptoInterval), fiatInterval: isNaN(newOptions.fiatInterval) ?
                this.options.fiatInterval :
                Math.max(60 * 30 * 1e3, newOptions.fiatInterval), 
            /**
             * Maximum 1000
             * If the limit is too high, it might cause some memory and performance issues.
             */
            listLimit: isNaN(newOptions.listLimit) ?
                this.options.listLimit :
                Math.max(1, Math.min(1000, parseInt(newOptions.listLimit + ''))) });
        //Update current prices
        if ((exchangesUpdated || averageUpdated) && this.isReady) {
            if (helpers_1.isBrowser || this.options.useHostedAPI) {
                return this.browserTicker();
            }
            else {
                if (this.options.disableExchangeMode === 'noCache' || disabledExchangesModeUpdated) {
                    return this.updateCrypto();
                }
                this.data.crypto.current = this.joinPrices(this.data);
            }
        }
        return this;
    }
    get isCustomServerHost() {
        return !/^https?:\/\/api\.coinconvert\.net/i.test(this.options.serverHost);
    }
    updateCrypto() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.data.crypto.last_updated) {
                this.log("Updating crypto...");
            }
            const tickers = this.exchanges.reduce((o, exchange) => (Object.assign(Object.assign({}, o), { [exchange]: api_1.default[exchange].ticker })), {});
            let currents = [], current = {};
            for (const ticker in tickers) {
                if (!this.options[ticker] && this.options.disableExchangeMode !== 'saveAllCache') {
                    continue;
                }
                try {
                    this.data.crypto[ticker] = yield tickers[ticker]();
                    if (this.options[ticker]) {
                        currents.push(this.data.crypto[ticker]);
                        current = Object.assign(Object.assign({}, current), this.data.crypto[ticker]);
                        this.data.crypto.last_updated = (+new Date());
                    }
                }
                catch (err) {
                    this.data.crypto[ticker] = null;
                    console.error(`Failed fetching prices from ${ticker}`, err);
                }
            }
            if (currents.length) {
                this.data.crypto.current = this.options.calculateAverage ? Object.assign(Object.assign({}, current), (0, helpers_1.getAverage)(currents)) : current;
                if (typeof this.options.onUpdate === "function") {
                    this.options.onUpdate(this.data.crypto);
                }
            }
            return this;
        });
    }
    updateFiat() {
        return __awaiter(this, void 0, void 0, function* () {
            this.log("Updating fiat...");
            try {
                this.data.fiat.current = yield api_1.default.fiat.all();
                this.data.fiat.last_updated = (+new Date());
                if (typeof this.options.onUpdate === "function") {
                    this.options.onUpdate(this.data.fiat, true);
                }
            }
            catch (err) {
                console.error(`Failed fetching fiat prices from ECB`, err);
            }
            return this;
        });
    }
    updateLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.data.crypto.last_updated) {
                this.log("Updating top currency list...");
            }
            try {
                const getTopList = yield api_1.default.coinmarketcap.top({
                    limit: this.options.listLimit + ''
                });
                this.list.crypto = Object.keys(getTopList);
                this.cryptoInfo = getTopList;
                if (typeof this.onCryptoListRefresh == "function" && this.isReady) {
                    this.onCryptoListRefresh(this.list.crypto);
                }
            }
            catch (err) {
                console.error(`Failed fetching fiat prices from ECB`, err);
            }
            return this;
        });
    }
    joinPrices(data) {
        const exchangesData = this.exchanges.reduce((o, exchange) => (Object.assign(Object.assign({}, o), { [exchange]: data.crypto[exchange] })), {});
        let currents = [], current = {};
        for (const exchange in exchangesData) {
            if (!this.options[exchange] || !exchangesData[exchange]) {
                continue;
            }
            currents.push(exchangesData[exchange]);
            current = Object.assign(Object.assign({}, current), exchangesData[exchange]);
        }
        return this.options.calculateAverage ? Object.assign(Object.assign({}, current), (0, helpers_1.getAverage)(currents)) : current;
    }
    browserTicker() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const currentOptions = this.options;
                const disabledExchanges = this.exchanges.filter((exchange) => !currentOptions[exchange]);
                const data = yield this.hostedAPI.ticker(disabledExchanges.length ? {
                    'filterExchanges': disabledExchanges,
                    'noAverage': !this.options.calculateAverage ? true : undefined
                } : {});
                this.data = data;
                if (typeof this.options.onUpdate === "function") {
                    this.options.onUpdate(this.data);
                }
            }
            catch (err) {
                console.error(`Failed fetching prices from API`, err);
            }
            return this;
        });
    }
    browserLists() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const getTopList = yield this.hostedAPI.list();
                this.list.crypto = Object.keys(getTopList.crypto);
                this.list.fiat = getTopList.fiat;
                this.cryptoInfo = getTopList.crypto;
                if (typeof this.onCryptoListRefresh == "function" && this.isReady) {
                    this.onCryptoListRefresh(this.list.crypto);
                }
            }
            catch (err) {
                console.error('Failed fetching currencies list from API', err);
            }
            return this;
        });
    }
    runBrowser() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window !== "undefined" && window['__ccRunning']) {
                throw new Error(`The crypto-convert worker seems to be already running. 
			- There might be an issue with the way your app imports javascript dependencies. 
			- Make sure to call 'convert.stop()' on component unmounts if you are using SPA frameworks (e.g React).`);
            }
            //First run only
            if (!this.isReady) {
                yield this.browserTicker();
                //Update lists
                yield this.browserLists();
                if (!this.isRunning) {
                    return false;
                }
                if (!helpers_1.isBrowser && this.options.useHostedAPI && this.options.refreshCryptoList) {
                    this.lists_worker = setInterval(this.browserLists.bind(this), 86400 //every day
                    );
                }
            }
            this.crypto_worker = setInterval(this.browserTicker.bind(this), this.options.cryptoInterval);
            this.isReady = true;
            if (typeof window !== "undefined") {
                window['__ccRunning'] = true;
                if (window['__ccRunID']) {
                    clearInterval(window['__ccRunID']);
                }
                window['__ccRunID'] = this.crypto_worker;
            }
            return this;
        });
    }
    runServer() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateLists();
            yield this.updateFiat();
            yield this.updateCrypto();
            if (!this.isRunning) {
                return false;
            }
            this.isReady = true;
            this.crypto_worker = setInterval(this.updateCrypto.bind(this), this.options.cryptoInterval);
            this.fiat_worker = setInterval(this.updateFiat.bind(this), this.options.fiatInterval);
            if (this.options.refreshCryptoList) {
                this.lists_worker = setInterval(this.updateLists.bind(this), 86400 //every day
                );
            }
            return this;
        });
    }
    run() {
        if (this.isRunning || this.crypto_worker) {
            throw new Error("Crypto-convert is already running.");
        }
        this.isRunning = true;
        if (helpers_1.isBrowser || this.options.useHostedAPI) {
            return this.runBrowser();
        }
        return this.runServer();
    }
    stop() {
        this.isRunning = false;
        clearInterval(this.crypto_worker);
        clearInterval(this.fiat_worker);
        this.crypto_worker = null;
        this.fiat_worker = null;
        if (this.lists_worker) {
            clearInterval(this.lists_worker);
            this.lists_worker = null;
        }
        if (typeof window !== "undefined") {
            window['__ccRunning'] = false;
        }
        return this;
    }
    restart() {
        return this.stop().run();
    }
}
exports.default = PricesWorker;
